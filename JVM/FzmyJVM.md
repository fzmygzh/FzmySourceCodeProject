一、基础知识

1、java跨平台

实现原因：java虚拟机(JVM)是java跨平台的核心操作

<img src="C:\Users\dingfeng\AppData\Roaming\Typora\typora-user-images\1621055042632.png" alt="1621055042632" style="zoom:50%;" />

2、JVM基础知识

​		java代码执行步骤：xxx.java->xxx.class->类加载子系统->运行时数据区<-字节码执行引擎

​        **运行时数据区是jvm的核心部分，通常jvm调休指的就是针对这部分优化。**

​        **运行时数据区**主要由：**堆**（new的对象一般都存在堆中）、**栈（线程）**[局部变量表（对象类型数据在此存的是内存地址，也叫指针）、操作数栈、动态链接（根据某一符号找到对应的方法区的内存入口地址）、方法出口（返回上一个方法的方法区地址，返回值就是这个时候塞进去）]、**本地方法栈**（native修饰的就是方法）、**方法区（元空间）**[常量、静态变量、类信息]、**程序计数器**

![1621059025155](C:\Users\dingfeng\AppData\Roaming\Typora\typora-user-images\1621059025155.png)

![1621059069298](C:\Users\dingfeng\AppData\Roaming\Typora\typora-user-images\1621059069298.png)

以上述代码为例：

​		在栈（线程）中，先开辟一块main方法的栈帧（压栈、入栈），然后new Math对象后，调用compute方法，开辟compute的栈帧，初始化其中数据后，处理逻辑，返回时，根据方法出口找到main地址，将返回值一并返回到main中。

3、JVM垃圾回收

​		Java判断某一对象是否需要进行垃圾回收有两种方法：

​        1).**引用计数法**：假设堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并且初始化赋值后，该对象的计数器的值就设置为 1，每当有一个地方引用它时，计数器的值就加 1，例如将对象 b 赋值给对象 a，那么 b 被引用，则将 b 引用对象的计数器累加 1。反之，当引用失效时，例如一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，则之前被引用的对象的计数器的值就减 1。而那些引用计数为 0 的对象，就可以称之为垃圾，可以被收集。

​		**优点**：引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。
​		**缺点**：需要额外的空间来存储计数器，难以检测出对象之间的循环引用。

 2).**可达性分析算法**：以GC Roots对象为起点，对这些节点向下搜索引用的对象，找到对象则标记未非垃圾对象，其余未标记的是垃圾对象。

​		 判断为可达 依据：

​										对象是属于根集中的对象
​										对象被一个可达的对象引用

​		GC Roots对象：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中的常量引用的对象、方法区中的类静态属性引用的对象、本地方法栈中 JNI（Native 方法）的引用对象、活跃线程（已启动且未停止的 Java 线程）

**注意：**可达性分析算法 真正宣告一个对象死亡，至少要经历两次标记过程：

​			a.当对象进行根可达性分析时，发现没有和根对象相连，会被第一次标记和筛选，这是会判断是否需要执行 finalize() 方法，如果对象不需要执行，或依据执行过了，这时会被回收；

​			b.当对象没有和根对象相连，但是还有finalize()需要执行时，JVM会将该对象放置到 F-Queue 队列中，由一个低优先级的线程去操作，如果这时候对象又建立新的链接，则不会被回收。

4、Java对象

![1621071103057](C:\Users\dingfeng\AppData\Roaming\Typora\typora-user-images\1621071103057.png)

java对象组成部分：对象头、实例数据、对其数据；

5、垃圾收集器

![1621072873537](C:\Users\dingfeng\AppData\Roaming\Typora\typora-user-images\1621072873537.png)

Java目前市面使用的是分代垃圾回收器，即年轻代和老年代两个部分。

![1621073002635](C:\Users\dingfeng\AppData\Roaming\Typora\typora-user-images\1621073002635.png)

年轻代（新生代）：

​		 内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。 大部分对象是现在eden区生成，当eden满了后会触发minorGC。 新生代大小可以由`-Xmn`来控制，也可以用`-XX:SurvivorRatio`来控制 Eden 和 Survivor 的比例 

老年代：

​		 新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中 ，也就是说老年代存放的都是一些活的久的老对象（通常是16岁之后就过来了）；内存一般是新生态的2倍，当老年代内存满了会触发fullgc。

永生代：

​		 用于存放静态文件（`class`类、方法）和常量等。  永久代在 Java SE8 特性中已经被移除了，取而代之的是元空间（`MetaSpace`），因此也不会再出现`java.lang.OutOfMemoryError: PermGen error`的错误了。 

